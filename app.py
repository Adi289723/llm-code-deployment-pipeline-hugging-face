from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import json
import base64
import hashlib
import time
from pprint import pprint
from datetime import datetime
import requests
import logging
from dotenv import load_dotenv

load_dotenv()

# Configure logging for production
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app, origins=["*"])

class Config:
    SECRET = os.environ.get('SECRET_KEY')
    GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')
    AIPIPE_TOKEN = os.environ.get('AIPIPE_TOKEN')
    GITHUB_USERNAME = os.environ.get('GITHUB_USERNAME')
    PORT = int(os.environ.get('PORT', 7860))  # Default Hugging Face port

config = Config()

class GitHubManager:
    
    def __init__(self, token, username):
        self.token = token
        self.username = username
        self.headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'LLM-Code-Deployment-Bot'
        }
        self.base_url = 'https://api.github.com'

    def create_repository(self, repo_name, description="Generated by LLM Code Deployment"):
        """Create a new GitHub repository"""
        data = {
            'name': repo_name,
            'description': description,
            'private': False,
            'auto_init': True
        }
        
        response = requests.post(
            f'{self.base_url}/user/repos',
            headers=self.headers,
            json=data
        )
        
        if response.status_code == 201:
            return response.json()
        else:
            error_detail = response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
            logger.error(f"Failed to create repository '{repo_name}': {response.status_code}")
            logger.error(f"GitHub response: {error_detail}")
            raise Exception(f"Failed to create repository: {response.status_code} - {error_detail}")

    def create_file(self, repo_name, file_path, content, commit_message):
        """Create or update a file in the repository"""
        check_url = f'{self.base_url}/repos/{self.username}/{repo_name}/contents/{file_path}'
        check_response = requests.get(check_url, headers=self.headers)
        
        encoded_content = base64.b64encode(content.encode('utf-8')).decode('utf-8')
        data = {
            'message': commit_message,
            'content': encoded_content,
            'committer': {
                'name': self.username,
                'email': f'{self.username}@users.noreply.github.com'
            }
        }
        
        if check_response.status_code == 200:
            file_data = check_response.json()
            data['sha'] = file_data['sha']
            logger.info(f"Updating existing file: {file_path}")
        else:
            logger.info(f"Creating new file: {file_path}")
        
        response = requests.put(
            check_url,
            headers=self.headers,
            json=data
        )
        
        if response.status_code in [201, 200]:
            return response.json()
        else:
            error_detail = response.json() if response.headers.get('content-type') == 'application/json' else response.text
            logger.error(f"Failed to create file {file_path}: {response.status_code}")
            logger.error(f"Response: {error_detail}")
            raise Exception(f"Failed to create file: {response.status_code}")

    def enable_pages(self, repo_name):
        data = {
            'source': {
                'branch': 'main',
                'path': '/'
            }
        }
        
        response = requests.post(
            f'{self.base_url}/repos/{self.username}/{repo_name}/pages',
            headers=self.headers,
            json=data
        )
        
        if response.status_code in [201, 200, 409]:
            return True
        else:
            logger.error(f"Failed to enable pages: {response.text}")
            return False

    def get_latest_commit(self, repo_name, branch='main'):
        response = requests.get(
            f'{self.base_url}/repos/{self.username}/{repo_name}/commits/{branch}',
            headers=self.headers
        )
        
        if response.status_code == 200:
            return response.json()['sha']
        else:
            logger.error(f"Failed to get latest commit: {response.text}")
            return None

class CodeGenerator:

    def __init__(self, aipipe_token):
        self.token = aipipe_token

    def generate_app(self, brief, attachments=None, checks=None):
        """Generate app code based on brief and requirements"""
        prompt = f"""
        Create a complete single-page web application based on this brief:
        {brief}
        
        Requirements:
        - Create a complete HTML file with embedded CSS and JavaScript
        - Make it functional and interactive  
        - Include Bootstrap 5 from jsdelivr CDN
        - Handle any attachments or data provided
        - Ensure the app meets these checks: {checks if checks else 'Basic functionality'}
        
        Generate ONLY the HTML content - no explanations or markdown formatting.
        The HTML should be complete and ready to deploy.
        """
        
        if attachments:
            prompt += f"\n\nAttachments provided: {len(attachments)} files"
            for att in attachments:
                if att.get('name'):
                    prompt += f"\n- {att['name']}"
        
        try:
            response = requests.post(
                "https://aipipe.org/openrouter/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.token}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "openai/gpt-4o-mini",
                    "messages": [
                        {"role": "system", "content": "You are an expert web developer. Generate clean, functional HTML/CSS/JS applications."},
                        {"role": "user", "content": prompt}
                    ],
                    "max_tokens": 4000,
                    "temperature": 0.3
                },
                timeout=60
            )
            
            response.raise_for_status()
            result = response.json()
            return result['choices'][0]['message']['content']
        
        except Exception as e:
            logger.error(f"Failed to generate code: {str(e)}")
            raise Exception(f"Code generation failed: {str(e)}")

    def generate_readme(self, brief, repo_name, pages_url):
        """Generate README.md content"""
        prompt = f"""
Create a professional README.md for a web application with:
- Project title: {repo_name}
- Brief description: {brief}
- Live demo link: {pages_url}
- Setup instructions
- Usage guide
- Technology stack
- License information (MIT)

Make it professional and comprehensive.
"""
        
        try:
            response = requests.post(
                "https://aipipe.org/openrouter/v1/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.token}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "openai/gpt-4o-mini", 
                    "messages": [
                        {"role": "system", "content": "You are a technical writer creating professional documentation."},
                        {"role": "user", "content": prompt}
                    ],
                    "max_tokens": 1500,
                    "temperature": 0.3
                },
                timeout=60
            )
            
            response.raise_for_status()
            result = response.json()
            return result['choices'][0]['message']['content']
        
        except Exception as e:
            logger.error(f"Failed to generate README: {str(e)}")
            return f"# {repo_name}\n\n{brief}\n\n## Live Demo\n{pages_url}\n\n## License\nMIT"

def retry_request(func, max_retries=3, delay=1):
    for attempt in range(max_retries):
        try:
            return func()
        except Exception as e:
            if attempt == max_retries - 1:
                raise e
            time.sleep(delay * (2 ** attempt))
            logger.warning(f"Attempt {attempt + 1} failed, retrying in {delay * (2 ** attempt)} seconds")

@app.route('/', methods=['GET'])
def health_check():
    return jsonify({
        'status': 'healthy',
        'service': 'LLM Code Deployment API',
        'timestamp': datetime.now().isoformat(),
        'platform': 'Hugging Face'
    })

@app.route('/api/deploy', methods=['POST'])
def deploy_app():
    
    if not request.is_json:
        return jsonify({'error': 'Content-Type must be application/json'}), 400
    
    data = request.get_json()
    logger.info("Received deploy request")
    
    required_fields = ['email', 'secret', 'task', 'round', 'nonce', 'brief', 'evaluation_url']
    for field in required_fields:
        if field not in data.keys():
            return jsonify({'error': f'Missing required field: {field}'}), 400
    
    if data.get('secret', 'dummy') != config.SECRET:
        return jsonify({'error': 'Invalid secret'}), 401

    if data.get('round', 0) == 1:

        try:
            
            logger.info(f"Processing deployment request for task for Round 1: {data['task']}")
            
            github_manager = GitHubManager(config.GITHUB_TOKEN, config.GITHUB_USERNAME)
            code_generator = CodeGenerator(config.AIPIPE_TOKEN)
            
            repo_name = f"{data['task']}"
            
            logger.info(f"Creating repository: {repo_name}")
            
            app_code = code_generator.generate_app(
                data['brief'],
                data.get('attachments', []),
                data.get('checks', [])
            )
            
            repo_info = github_manager.create_repository(repo_name, data['brief'])
            time.sleep(5)
            
            logger.info("Repository initialized, creating LICENSE...")
            
            license_content = """MIT License
    
            Copyright (c) 2025
            
            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:
            
            The above copyright notice and this permission notice shall be included in all
            copies or substantial portions of the Software.
            
            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            SOFTWARE."""
            
            github_manager.create_file(repo_name, 'LICENSE', license_content, 'Add MIT License')
            logger.info("LICENSE created for Round 1")
            
            github_manager.create_file(
                repo_name,
                'index.html',
                app_code,
                'Initial commit: Add generated application'
            )
            
            time.sleep(5)
            github_manager.enable_pages(repo_name)
            logger.info("GitHub Pages enabled for Round 1")
            
            pages_url = f"https://{config.GITHUB_USERNAME}.github.io/{repo_name}/"
            
            readme_content = code_generator.generate_readme(data['brief'], repo_name, pages_url)
            github_manager.create_file(
                repo_name,
                'README.md',
                readme_content,
                'Add comprehensive README'
            )
            
            logger.info("README.md created for Round 1")
            
            commit_sha = github_manager.get_latest_commit(repo_name)
            logger.info(f"Latest commit SHA: {commit_sha}")
            
            evaluation_data = {
                'email': data['email'],
                'task': data['task'],
                'round': data['round'],
                'nonce': data['nonce'],
                'repo_url': repo_info['html_url'],
                'commit_sha': commit_sha,
                'pages_url': pages_url
            }
            
            def send_evaluation():
                response = requests.post(
                    data['evaluation_url'],
                    headers={'Content-Type': 'application/json'},
                    json=evaluation_data,
                    timeout=30
                )
                
                if response.status_code != 200:
                    raise Exception(f"Evaluation endpoint returned {response.status_code}")
                return response
            
            logger.info("Sending evaluation data for round 1...")
            retry_request(send_evaluation)
            
            logger.info(f"Deployment completed successfully for task: {data['task']}")
            logger.info(f"GitHub Repository URL: {repo_info['html_url']}")
            logger.info(f"GitHub Pages URL: {pages_url}")
            
            return jsonify({
                'status': 'success',
                'message': 'Application deployed successfully',
                'repo_url': repo_info['html_url'],
                'pages_url': pages_url,
                'commit_sha': commit_sha
            }), 200
            
        except Exception as e:
            logger.error(f"Deployment failed: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': str(e)
            }), 500

    elif data.get('round', 0) == 2:

        try:

            time.sleep(15)
            logger.info(f"Processing round 2 update request for task: {data['task']}")
        
            repo_name = f"{data['task']}"
            
            logger.info(f"Updating repository for Round 2: {repo_name}")
            
            github_manager = GitHubManager(config.GITHUB_TOKEN, config.GITHUB_USERNAME)
            code_generator = CodeGenerator(config.AIPIPE_TOKEN)
            
            updated_code = code_generator.generate_app(
                data['brief'],
                data.get('attachments', []),
                data.get('checks', [])
            )
            
            logger.info("Generated updated application code for round 2.")
            
            github_manager.create_file(
                repo_name,
                'index.html',
                updated_code,
                f'Round 2 update: {data["brief"][:50]}...'
            )
            
            logger.info("Updated code in repository.")
            
            time.sleep(5)
            
            pages_url = f"https://{config.GITHUB_USERNAME}.github.io/{repo_name}/"
            
            updated_readme = code_generator.generate_readme(data['brief'], repo_name, pages_url)
            github_manager.create_file(
                repo_name,
                'README.md',
                updated_readme,
                'Update README for round 2 changes'
            )
            
            logger.info("Updated README.md in repository.")
            
            commit_sha = github_manager.get_latest_commit(repo_name)
            logger.info(f"Latest commit SHA after update in round 2: {commit_sha}")
            
            evaluation_data = {
                'email': data['email'],
                'task': data['task'],
                'round': data['round'],
                'nonce': data['nonce'],
                'repo_url': f"https://github.com/{config.GITHUB_USERNAME}/{repo_name}",
                'commit_sha': commit_sha,
                'pages_url': pages_url
            }
            
            def send_evaluation():
                response = requests.post(
                    data['evaluation_url'],
                    headers={'Content-Type': 'application/json'},
                    json=evaluation_data,
                    timeout=30
                )
                
                if response.status_code != 200:
                    raise Exception(f"Evaluation endpoint returned {response.status_code}")
                return response
            
            retry_request(send_evaluation)
            
            return jsonify({
                'status': 'success',
                'message': 'Application updated successfully',
                'commit_sha': commit_sha
            }), 200
            
        except Exception as e:
            logger.error(f"Update failed: {str(e)}")
            return jsonify({
                'status': 'error',
                'message': str(e)
            }), 500

    else:

        return jsonify({'error': 'Invalid round number'}), 400

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=config.PORT, debug=False)
